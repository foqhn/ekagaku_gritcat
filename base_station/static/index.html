<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Robot Controller</title>
    <link rel="stylesheet" href="/static/style/joystick.css">
    <style>
        body { font-family: sans-serif; display: flex; }
        #controls, #data { margin: 20px; }
        #camera { border: 1px solid black; min-width: 640px; min-height: 480px; background-color: #333; }
        button { width: 100px; height: 50px; margin: 5px; }
        #speed-slider { vertical-align: middle; }
    </style>
</head>
<body>
    <div>
        <h2>Camera</h2>
        <img id="camera" src="" alt="Camera Stream">
    </div>
    <div id="data">
        <h2>IMU Data</h2>
        <pre id="imu-data">Connecting...</pre>
        <h3>Connection</h3>
        <div>
            <label for="robot-select">Robot ID:</label>
            <select id="robot-select">
                <!-- サーバから動的に埋められます -->
            </select>
            <button id="connect-btn">Connect</button>
            <span id="conn-status">Not connected</span>
        </div>
        <h2>Controls</h2>
        <div>
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="0" max="100" value="50">
            <span id="speed-value">50</span>
        </div>
        <div class="controls-wrapper">
            <div>
                <div class="joystick-container" id="joystick">
                    <div class="joy-base">
                        <div class="joy-knob" id="joy-knob"></div>
                    </div>
                </div>
                <div class="joy-info" id="joy-info">Neutral</div>
            </div>
            <div>
                <button class="stop-btn-small" id="stop-btn">Stop</button>
            </div>
        </div>
    </div>
<script>
    // UI elements
    const cameraImage = document.getElementById('camera');
    const imuDataElement = document.getElementById('imu-data');
    const robotSelect = document.getElementById('robot-select');
    const connectBtn = document.getElementById('connect-btn');
    const connStatus = document.getElementById('conn-status');
    const speedSlider = document.getElementById('speed-slider');
    const speedValue = document.getElementById('speed-value');

    let ws = null;
    let connectedRobotId = null;

    // スライダーの値表示を更新
    speedSlider.addEventListener('input', () => {
        speedValue.textContent = speedSlider.value;
    });

    function updateStatus(text, ok = false) {
        connStatus.textContent = text;
        connStatus.style.color = ok ? 'green' : 'red';
    }

    function connectToSelectedRobot() {
        const robotId = robotSelect.value.trim();
        if (!robotId) return;

        // Close existing connection if any
        if (ws) {
            try { ws.close(); } catch (e) { /* ignore */ }
            ws = null;
            connectedRobotId = null;
        }

        const url = `ws://${window.location.host}/ws/frontend/${robotId}`;
        ws = new WebSocket(url);

        updateStatus('Connecting...', false);

        ws.binaryType = 'blob';

        ws.onopen = () => {
            console.log('Connected to server for', robotId);
            connectedRobotId = robotId;
            updateStatus(`Connected: ${robotId}`, true);
            imuDataElement.textContent = 'Connection established. Waiting for data...';
        };

        ws.onmessage = (event) => {
            if (event.data instanceof Blob) {
                cameraImage.src = URL.createObjectURL(event.data);
            } else {
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'imu') {
                        imuDataElement.textContent = JSON.stringify(message.data, null, 2);
                    }
                } catch (e) {
                    console.error('Failed to parse JSON:', e);
                }
            }
        };

        ws.onclose = () => {
            console.log('Connection closed.');
            imuDataElement.textContent = 'Connection closed.';
            updateStatus('Not connected', false);
            connectedRobotId = null;
            ws = null;
        };

        ws.onerror = (error) => {
            console.error('WebSocket Error:', error);
            imuDataElement.textContent = 'Connection error.';
            updateStatus('Connection error', false);
        };
    }

    connectBtn.addEventListener('click', connectToSelectedRobot);

    // サーバからロボット一覧を取得してセレクトを更新
    async function fetchRobotList() {
        try {
            const resp = await fetch(`/api/robots`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const list = await resp.json();
            populateRobotSelect(list);
        } catch (e) {
            console.error('Failed to fetch robot list:', e);
        }
    }

    function populateRobotSelect(list) {
        // 現在選ばれている値を保持
        const current = robotSelect.value;
        robotSelect.innerHTML = '';
        if (!Array.isArray(list) || list.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = '-- no robots --';
            robotSelect.appendChild(opt);
            return;
        }
        list.forEach(id => {
            const opt = document.createElement('option');
            opt.value = id;
            opt.textContent = id;
            robotSelect.appendChild(opt);
        });
        // 可能なら以前の選択を復元
        if (current && Array.from(robotSelect.options).some(o => o.value === current)) {
            robotSelect.value = current;
        }
    }

    // 初回取得とポーリング（例: 5秒間隔）
    fetchRobotList();
    setInterval(fetchRobotList, 5000);

    /**
     * バックエンドにコマンドを送信する共通関数
     * @param {string} command - コマンド名 (例: 'move')
     * @param {number} left - 左モーターの速度
     * @param {number} right - 右モーターの速度
     */
    function sendCommand(command, left, right) {
        const payload = {
            command: command,
            left: left,
            right: right
        };
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(payload));
            console.log('Sent:', payload);
        } else {
            console.warn('WebSocket is not open. Cannot send command.');
        }
    }

    /**
     * スライダーの値を使って移動コマンドを送信する
     * @param {string} direction - 'forward', 'backward', 'left', 'right'
     */
    function move(direction) {
        const speed = parseInt(speedSlider.value, 10);
        let left = 0;
        let right = 0;

        switch (direction) {
            case 'forward':
                left = speed;
                right = speed;
                break;
            case 'backward':
                left = -speed;
                right = -speed;
                break;
            case 'left':
                left = -speed;
                right = speed;
                break;
            case 'right':
                left = speed;
                right = -speed;
                break;
        }
        sendCommand('move', left, right);
    }

    /**
     * 停止コマンドを送信する
     */
    function stop() {
        sendCommand('move', 0, 0);
    }

    // --- Joystick implementation ---
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('joy-knob');
    const joyInfo = document.getElementById('joy-info');
    const stopBtn = document.getElementById('stop-btn');

    let dragging = false;
    let joyRect = null;

    function updateKnobPosition(x, y) {
        const cx = joyRect.width / 2;
        const cy = joyRect.height / 2;
        const maxRadius = (joyRect.width / 2) - (knob.offsetWidth / 2) - 4; // padding
        const dx = x - (joyRect.left + cx);
        const dy = y - (joyRect.top + cy);
        // clamp to circle
        const dist = Math.sqrt(dx*dx + dy*dy);
        const r = Math.min(dist, maxRadius);
        const angle = Math.atan2(dy, dx);
        const nx = r * Math.cos(angle);
        const ny = r * Math.sin(angle);
        knob.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;

        // normalize to -1..1
        const nxNorm = (nx / maxRadius);
        const nyNorm = (-ny / maxRadius); // invert Y so up is positive

        // Map joystick to differential drive
        // forward/backward: nyNorm (-1..1)
        // left/right rotation: nxNorm (-1..1)
        const baseSpeed = parseInt(speedSlider.value, 10) / 100; // 0..1

        // Simple mixing: left = forward*base +- turn*base
        const left = Math.round((nyNorm + (-nxNorm)) * baseSpeed * 100);
        const right = Math.round((nyNorm + (nxNorm)) * baseSpeed * 100);

        joyInfo.textContent = `L:${left} R:${right}`;

        // send command continuously while dragging
        if (dragging) sendCommand('move', left, right);
    }

    function resetKnob() {
        knob.style.transform = 'translate(-50%, -50%)';
        joyInfo.textContent = 'Neutral';
    }

    function onPointerDown(e) {
        e.preventDefault();
        dragging = true;
        joyRect = joystick.getBoundingClientRect();
        joystick.setPointerCapture(e.pointerId);
        updateKnobPosition(e.clientX, e.clientY);
    }

    function onPointerMove(e) {
        if (!dragging) return;
        updateKnobPosition(e.clientX, e.clientY);
    }

    function onPointerUp(e) {
        dragging = false;
        try { joystick.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
        resetKnob();
        stop();
    }

    joystick.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    stopBtn.addEventListener('click', () => { resetKnob(); stop(); });

</script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Robot Controller</title>
    <link rel="stylesheet" href="/static/style/joystick.css">
    <link rel="stylesheet" href="/static/style/index.css">
    <style>
        body {
            font-family: sans-serif;
            display: flex;
        }

        button {
            width: 100px;
            height: 50px;
            margin: 5px;
        }

        #download-btn {
            width: 120px;
        }
    </style>
</head>

<body>
    <div id="window">
        <div id='header'>
            <div>
                <label for="robot-select">Robot ID:</label>
                <select id="robot-select">
                    <!-- サーバから動的に埋められます -->
                </select>
                <button id="connect-btn">Connect</button>
                <span id="conn-status">Not connected</span>
            </div>
            <div>
                <pre id="wifi-data">Connecting...</pre>
            </div>
        </div>
        <div id="base-container">
            <div id="left-side">
                <h2>Sensor</h2>
                <div>
                    Camera<br>
                    <label class="toggle-switch">
                        <input type="checkbox" id="tgl_cam">
                        <span class="slider"></span>
                    </label><br>
                    IMU<br>
                    <label class="toggle-switch">
                        <input type="checkbox" id="tgl_imu">
                        <span class="slider"></span>
                    </label><br>
                    GPS<br>
                    <label class="toggle-switch">
                        <input type="checkbox" id="tgl_gps">
                        <span class="slider"></span>
                    </label><br>
                    Temperature<br>
                    <label class="toggle-switch">
                        <input type="checkbox" id="tgl_tempe">
                        <span class="slider"></span>
                    </label>
                </div>

                <hr color="#ff0000">
                <div>
                    LOG<br>
                    <label class="toggle-switch">
                        <input type="checkbox" id="tgl_log">
                        <span class="slider"></span>
                    </label>
                </div>

                </pre>

            </div>
            <div id="center">
                <div id="camera-window">
                    <img id="camera" src="" alt="Camera Stream" class="cam_stream">
                </div>
                <h2>Controls</h2>
                <div>
                    <label for="speed-slider">Speed:</label>
                    <input type="range" id="speed-slider" min="0" max="100" value="50">
                    <span id="speed-value">50</span>
                </div>
                <div class="controls-wrapper">
                    <div>
                        <div class="joystick-container" id="joystick">
                            <div class="joy-base">
                                <div class="joy-knob" id="joy-knob"></div>
                            </div>
                        </div>
                        <div class="joy-info" id="joy-info">Neutral</div>
                    </div>
                    <div>
                        <button class="stop-btn-small" id="stop-btn">Stop</button>
                    </div>
                </div>
            </div>
            <div id="right-side">
                <div id="data">
                    <h2>IMU</h2>
                    <pre id="imu-data">Connecting...</pre>
                    <h2>Magnetometer</h2>
                    <pre id="mag-data">Connecting...</pre>
                    <h2>GPS</h2>
                    <pre id="gps-data">Connecting...</pre>

                </div>
                <div id="logfile_mng">
                    <button id="reload-file">Reload</button>
                    <select id="file-select">
                        <option value="">-- Select a file --</option>
                    </select>
                    <!-- ★ 変更点: ダウンロードボタンを追加 (初期状態は非表示) -->
                    <button id="download-btn" style="display: none;">Download</button>
                </div>
            </div>

        </div>
    </div>
    </div>

    <script>
        // UI elements
        const cameraImage = document.getElementById('camera');
        const imuDataElement = document.getElementById('imu-data');
        const magDataElement = document.getElementById('mag-data');
        const gpsDataElement = document.getElementById('gps-data');
        const wifiDataElement = document.getElementById('wifi-data');
        const robotSelect = document.getElementById('robot-select');
        const connectBtn = document.getElementById('connect-btn');
        const connStatus = document.getElementById('conn-status');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');

        const reloadFileBtn = document.getElementById('reload-file');
        const fileSelect = document.getElementById('file-select');
        const downloadBtn = document.getElementById('download-btn');
        let ws = null;
        let connectedRobotId = null;

        // スライダーの値表示を更新
        speedSlider.addEventListener('input', () => {
            speedValue.textContent = speedSlider.value;
        });

        function updateStatus(text, ok = false) {
            connStatus.textContent = text;
            connStatus.style.color = ok ? 'green' : 'red';
        }

        function connectToSelectedRobot() {
            const robotId = robotSelect.value.trim();
            if (!robotId) return;

            // Close existing connection if any
            if (ws) {
                try { ws.close(); } catch (e) { /* ignore */ }
                ws = null;
                connectedRobotId = null;
            }

            const url = `ws://${window.location.host}/ws/frontend/${robotId}`;
            ws = new WebSocket(url);

            updateStatus('Connecting...', false);

            ws.onopen = () => {
                console.log('Connected to server for', robotId);
                connectedRobotId = robotId;
                updateStatus(`Connected: ${robotId}`, true);
                imuDataElement.textContent = 'Connection established. Waiting for data...';
            };

            // ★ 変更点: メッセージ処理をJSONペイロードを前提としたロジックに全面的に書き換え
            ws.onmessage = (event) => {
                try {
                    // 常にテキストデータ(JSON文字列)として受信し、パースする
                    const payload = JSON.parse(event.data);

                    // サーバーから送られてくるデータの型が 'sensor_data' であることを確認
                    if (payload.type === 'sensor_data' && payload.data) {
                        const data = payload.data;

                        // 1. 画像データが存在すれば、Base64文字列をデコードして表示
                        if (data.image) {
                            // 'data:image/jpeg;base64,' というプレフィックスを付けてsrcに設定する
                            cameraImage.src = 'data:image/jpeg;base64,' + data.image;
                        }

                        // 2. IMUデータが存在すれば、整形して表示
                        if (data.imu) {
                            imuDataElement.textContent = "Ready...";
                        }
                        if (data.mag) {
                            magDataElement.textContent = "Ready...";
                        }
                        if (data.gps) {
                            gpsDataElement.textContent = "Ready...";
                        }
                        if (data.wifi) {
                            wifiDataElement.textContent = JSON.stringify(data.wifi, null, 2);
                        }

                        // 3. 将来的にGPSなどのセンサーが増えた場合も、ここに追加できます
                        // if (data.gps) {
                        //     document.getElementById('gps-data').textContent = JSON.stringify(data.gps, null, 2);
                        // }
                    } else if (payload.type === 'log_file_list' && payload.files) {
                        console.log("Received file list:", payload.files);
                        populateFileSelect(payload.files);

                    } else if (payload.type === 'log_file_content' && payload.filename && payload.data) {
                        console.log(`Received content for ${payload.filename}`);
                        triggerDownload(payload.filename, payload.data);
                    }
                } catch (e) {
                    // JSONのパースに失敗した場合や、予期しないデータを受信した場合のエラー
                    console.error('Failed to process message:', e, event.data);
                }
            };


            ws.onclose = () => {
                console.log('Connection closed.');
                imuDataElement.textContent = 'Connection closed.';
                updateStatus('Not connected', false);
                connectedRobotId = null;
                ws = null;
                populateFileSelect([]);
                downloadBtn.style.display = 'none';
            };

            ws.onerror = (error) => {
                console.error('WebSocket Error:', error);
                imuDataElement.textContent = 'Connection error.';
                updateStatus('Connection error', false);
            };
        }

        connectBtn.addEventListener('click', connectToSelectedRobot);

        // サーバからロボット一覧を取得してセレクトを更新
        async function fetchRobotList() {
            try {
                const resp = await fetch(`/api/robots`);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const list = await resp.json();
                populateRobotSelect(list);
            } catch (e) {
                console.error('Failed to fetch robot list:', e);
            }
        }

        function populateRobotSelect(list) {
            // 現在選ばれている値を保持
            const current = robotSelect.value;
            robotSelect.innerHTML = '';
            if (!Array.isArray(list) || list.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = '-- no robots --';
                robotSelect.appendChild(opt);
                return;
            }
            list.forEach(id => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = id;
                robotSelect.appendChild(opt);
            });
            // 可能なら以前の選択を復元
            if (current && Array.from(robotSelect.options).some(o => o.value === current)) {
                robotSelect.value = current;
            }
        }

        // 初回取得とポーリング（例: 5秒間隔）
        fetchRobotList();
        setInterval(fetchRobotList, 5000);

        /**
         * バックエンドにコマンドを送信する共通関数
         * @param {string} command - コマンド名 (例: 'move')
         * @param {number} left - 左モーターの速度
         * @param {number} right - 右モーターの速度
         */
        function sendCommand_MT(command, left, right) {
            const payload = {
                command: command,
                left: left,
                right: right
            };
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(payload));
                console.log('Sent:', payload);
            } else {
                console.warn('WebSocket is not open. Cannot send command.');
            }
        }
        function sendCommand_SENSOR(sensor_type, bool) {
            let command = 'sensor';
            const payload = {
                command: command,
                sensor_type: sensor_type,
                bin: bool
            };
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(payload));
                console.log('Sent:', payload);
            } else {
                console.warn('WebSocket is not open. Cannot send command.');
            }
        }

        function sendCommand_GNL(command, str) {
            const payload = {
                command: command,
                msg: str
            };
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(payload));
                console.log('Sent:', payload);
            } else {
                console.warn('WebSocket is not open. Cannot send command.');
            }
        }

        function requestLogFile(filename) {
            const payload = {
                command: 'get_log_file',
                filename: filename
            };
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(payload));
                console.log('Requested file:', filename);
            } else {
                console.warn('WebSocket is not open. Cannot request file.');
            }
        }

        // --- ここから下のJoystickやコマンド送信のロジックは変更ありません ---

        /**
         * スライダーの値を使って移動コマンドを送信する
         * @param {string} direction - 'forward', 'backward', 'left', 'right'
         */
        function move(direction) {
            const speed = parseInt(speedSlider.value, 10);
            let left = 0;
            let right = 0;

            switch (direction) {
                case 'forward':
                    left = speed;
                    right = speed;
                    break;
                case 'backward':
                    left = -speed;
                    right = -speed;
                    break;
                case 'left':
                    left = -speed;
                    right = speed;
                    break;
                case 'right':
                    left = speed;
                    right = -speed;
                    break;
            }
            sendCommand_MT('move', left, right);
        }

        /**
         * 停止コマンドを送信する
         */
        function stop() {
            sendCommand_MT('move', 0, 0);
        }

        // --- Joystick implementation ---
        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('joy-knob');
        const joyInfo = document.getElementById('joy-info');
        const stopBtn = document.getElementById('stop-btn');

        let dragging = false;
        let joyRect = null;

        function updateKnobPosition(x, y) {
            const cx = joyRect.width / 2;
            const cy = joyRect.height / 2;
            const maxRadius = (joyRect.width / 2) - (knob.offsetWidth / 2) - 4; // padding
            const dx = x - (joyRect.left + cx);
            const dy = y - (joyRect.top + cy);
            // clamp to circle
            const dist = Math.sqrt(dx * dx + dy * dy);
            const r = Math.min(dist, maxRadius);
            const angle = Math.atan2(dy, dx);
            const nx = r * Math.cos(angle);
            const ny = r * Math.sin(angle);
            knob.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;

            // normalize to -1..1
            const nxNorm = (nx / maxRadius);
            const nyNorm = (-ny / maxRadius); // invert Y so up is positive

            // Map joystick to differential drive
            // forward/backward: nyNorm (-1..1)
            // left/right rotation: nxNorm (-1..1)
            const baseSpeed = parseInt(speedSlider.value, 10) / 100; // 0..1

            // Simple mixing: left = forward*base +- turn*base
            const right = Math.round((nyNorm + (-nxNorm)) * baseSpeed * 100);
            const left = Math.round((nyNorm + (nxNorm)) * baseSpeed * 100);

            joyInfo.textContent = `L:${left} R:${right}`;

            // send command continuously while dragging
            if (dragging) sendCommand_MT('move', left, right);
        }

        function resetKnob() {
            knob.style.transform = 'translate(-50%, -50%)';
            joyInfo.textContent = 'Neutral';
        }

        function onPointerDown(e) {
            e.preventDefault();
            dragging = true;
            joyRect = joystick.getBoundingClientRect();
            joystick.setPointerCapture(e.pointerId);
            updateKnobPosition(e.clientX, e.clientY);
        }

        function onPointerMove(e) {
            if (!dragging) return;
            updateKnobPosition(e.clientX, e.clientY);
        }

        function onPointerUp(e) {
            dragging = false;
            try { joystick.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
            resetKnob();
            stop();
        }

        joystick.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        stopBtn.addEventListener('click', () => { resetKnob(); stop(); });

        document.getElementById('tgl_cam').addEventListener('change', function () {
            sendCommand_SENSOR("cam", this.checked ? 1 : 0);
        });
        document.getElementById('tgl_imu').addEventListener('change', function () {
            sendCommand_SENSOR("imu", this.checked ? 1 : 0);
        });
        document.getElementById('tgl_gps').addEventListener('change', function () {
            sendCommand_SENSOR("gps", this.checked ? 1 : 0);
        });
        document.getElementById('tgl_log').addEventListener('change', function () {
            sendCommand_GNL("log", this.checked ? 1 : 0);
        });


        /**
         * ★ 新規: 受け取ったファイルリストでセレクトボックスを更新する関数
         * @param {string[]} files - ファイル名の配列
         */
        function populateFileSelect(files) {
            // 現在の選択を維持（もしあれば）
            const currentSelection = fileSelect.value;
            // セレクトボックスをクリア
            fileSelect.innerHTML = '';

            // デフォルトのオプションを追加
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "-- Select a file --";
            defaultOption.disabled = true; // 選択できないようにする
            defaultOption.selected = true; // 最初はこれを選択状態に
            fileSelect.appendChild(defaultOption);

            if (Array.isArray(files) && files.length > 0) {
                // ファイルリストをソートして追加（新しいものが上に来るように降順ソート）
                files.sort().reverse().forEach(filename => {
                    const option = document.createElement('option');
                    option.value = filename;
                    option.textContent = filename;
                    fileSelect.appendChild(option);
                });
            }

            // 以前の選択が新しいリストにあれば復元
            if (files.includes(currentSelection)) {
                fileSelect.value = currentSelection;
            }
        }

        /**
         * ★ 新規: CSVデータからダウンロードをトリガーする関数
         * @param {string} filename - ダウンロードするファイル名
         * @param {string} csvContent - CSVファイルの内容
         */
        function triggerDownload(filename, csvContent) {
            // BOMを追加してExcelでの文字化けを防ぐ
            const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
            const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8;' });

            // ダウンロード用のリンクを生成
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style.visibility = 'hidden';

            // リンクをクリックしてダウンロードを実行し、後片付け
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url); // メモリリークを防ぐ
        }


        // 'Reload' ボタンのクリックイベント
        reloadFileBtn.addEventListener('click', function () {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log("Requesting log file list...");
                // シンプルなコマンド送信に変更
                const payload = { command: 'list_log_files' };
                ws.send(JSON.stringify(payload));
            } else {
                alert("Not connected to any robot.");
            }
        });

        // ファイルセレクターの選択が変更された時のイベント
        fileSelect.addEventListener('change', function () {
            // 有効なファイルが選択されたらDownloadボタンを表示、そうでなければ非表示
            if (this.value) {
                downloadBtn.style.display = 'inline-block';
            } else {
                downloadBtn.style.display = 'none';
            }
        });

        // 'Download' ボタンのクリックイベント
        downloadBtn.addEventListener('click', function () {
            const selectedFile = fileSelect.value;
            if (selectedFile) {
                requestLogFile(selectedFile);
            } else {
                alert("Please select a file to download.");
            }
        });

    </script>
</body>

</html>